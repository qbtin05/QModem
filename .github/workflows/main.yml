name: "Auto compile with OpenWrt SDK"
on:
  workflow_dispatch:

env:
  TZ: Asia/Shanghai

jobs:
  job_auto_tag:
    #runs-on: ubuntu-latest
    runs-on: self-hosted
    # 只在 main 分支推送且包含 version.mk 文件变更时运行
    if: github.ref == 'refs/heads/main'
    outputs:
      new_tag: ${{ steps.create_tag.outputs.tag_name }}
      tag_created: ${{ steps.create_tag.outputs.tag_created }}
      extracted_tag: ${{ steps.extract_version.outputs.tag_name }}
      tag_exists: ${{ steps.check_tag.outputs.tag_exists }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Check if version.mk changed
      id: check_version_change
      run: |
        # 检查version.mk是否在这次提交中被修改
        echo "version_changed=true" >> $GITHUB_OUTPUT
    
    - name: Extract version from version.mk
      id: extract_version
      if: steps.check_version_change.outputs.version_changed == 'true'
      run: |
        # 从version.mk文件中提取QMODEM_VERSION
        version=$(grep "^QMODEM_VERSION" version.mk | sed 's/QMODEM_VERSION:=//' | xargs)
        echo "Current QMODEM_VERSION: $version"
        echo "version=$version" >> $GITHUB_OUTPUT
        
        # 检查version是否为空
        if [ -z "$version" ]; then
          echo "Error: Could not extract version from version.mk"
          exit 1
        fi
        
        # 生成tag名称
        tag_name="v$version"
        echo "tag_name=$tag_name" >> $GITHUB_OUTPUT
        echo "Generated tag name: $tag_name"
    
    - name: Check if tag already exists
      id: check_tag
      if: steps.check_version_change.outputs.version_changed == 'true'
      run: |
        tag_name="${{ steps.extract_version.outputs.tag_name }}"
        
        # 检查tag是否已经存在
        if git tag -l | grep -q "^${tag_name}$"; then
          echo "Tag $tag_name already exists, skipping tag creation"
          echo "tag_exists=true" >> $GITHUB_OUTPUT
        else
          echo "Tag $tag_name does not exist, will create it"
          echo "tag_exists=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Create and push tag
      id: create_tag
      if: steps.check_version_change.outputs.version_changed == 'true' && steps.check_tag.outputs.tag_exists == 'false'
      run: |
        tag_name="${{ steps.extract_version.outputs.tag_name }}"
        version="${{ steps.extract_version.outputs.version }}"
        
        # 配置git用户信息
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        
        # 创建带注释的tag
        git tag -a "$tag_name" -m "Release version $version - Auto-generated tag when QMODEM_VERSION was updated to $version"
        
        # 推送tag到远程仓库
        git push origin "$tag_name"
        
        echo "✅ Successfully created and pushed tag: $tag_name"
        echo "tag_name=$tag_name" >> $GITHUB_OUTPUT
        echo "tag_created=true" >> $GITHUB_OUTPUT

  job_prepare:
    #runs-on: ubuntu-latest
    runs-on: self-hosted
    needs: [job_auto_tag]
    if: always()  # 总是运行，不管 auto_tag 是否运行或是否成功
    outputs:
      branch_name: ${{ steps.determine_push.outputs.branch_name }}
      tag_name: ${{ steps.determine_push.outputs.tag_name }}
      push_type: ${{ steps.determine_push.outputs.push_type }}
      is_pr: ${{ steps.determine_push.outputs.is_pr }}

    steps:
      - name: Determine push type
        id: determine_push
        run: |
            # 如果 auto_tag job 创建了新标签，使用新标签
            if [[ "${{ needs.job_auto_tag.outputs.tag_created }}" == "true" ]]; then
              echo "New tag created: ${{ needs.job_auto_tag.outputs.new_tag }}"
              echo "tag_name=${{ needs.job_auto_tag.outputs.new_tag }}" >> $GITHUB_OUTPUT
              echo "push_type=tag" >> $GITHUB_OUTPUT
            # 如果标签已存在，使用提取的标签名
            elif [[ "${{ needs.job_auto_tag.outputs.tag_exists }}" == "true" ]] && [[ -n "${{ needs.job_auto_tag.outputs.extracted_tag }}" ]]; then
              echo "Tag already exists: ${{ needs.job_auto_tag.outputs.extracted_tag }}"
              echo "tag_name=${{ needs.job_auto_tag.outputs.extracted_tag }}" >> $GITHUB_OUTPUT
              echo "push_type=tag" >> $GITHUB_OUTPUT
            elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
              echo "This is a tag push."
              echo "tag_name=${{ github.ref_name }}" >> $GITHUB_OUTPUT
              echo "push_type=tag" >> $GITHUB_OUTPUT
            else
              echo "This is a branch push."
              echo "branch_name=${{ github.ref_name }}" >> $GITHUB_OUTPUT
              echo "push_type=branch" >> $GITHUB_OUTPUT
            fi
            is_pr=$([[ "${{ github.event_name }}" == "pull_request" ]] && echo 1 || echo 0)
            echo "is_pr=${is_pr}" >> $GITHUB_OUTPUT

      - name: Checkout
        if: 
        uses: actions/checkout@v2
        with:
          path: 'qmodem'

      - name: Generate Release Note
        id: update_modem_support_list
        run: |
          cd qmodem
          python3 ./scripts/update_support_list.py temp_support_list ./application/qmodem/files/usr/share/qmodem/modem_support.json
          mv temp_support_list_release_notes.md ./release_note.md
      
      - name: Upload Release Note
        id: upload_release_note
        uses: actions/upload-artifact@v4
        with:
          name: Release Note
          path: ./qmodem/release_note.md

  job_build_qmodem:
    name: Build QModem
    needs: [job_prepare]
    continue-on-error: true
    strategy:
      matrix:
        build_arch: ['arm64_ipk']
    #runs-on: ubuntu-latest
    runs-on: self-hosted
    steps:
      - name: Install packages
        run: |
          sudo -E apt-get -qq update
          sudo -E apt-get -qq install python3 python3-pyelftools swig zstd build-essential clang flex bison g++ gawk gcc-multilib g++-multilib gettext git libncurses5-dev libssl-dev python3-venv rsync unzip zlib1g-dev file wget
          sudo -E apt-get -qq autoremove --purge
          sudo -E apt-get -qq clean
          
          # Install CMake 3.31+ to meet rpcd-mod-luci requirements
          CMAKE_VERSION="3.31.5"
          CMAKE_DIR="/opt/cmake-${CMAKE_VERSION}-linux-x86_64"
          
          # Only download and install if not already present
          if [ ! -d "${CMAKE_DIR}" ]; then
            echo "Installing CMake ${CMAKE_VERSION}..."
            wget -q https://github.com/Kitware/CMake/releases/download/v${CMAKE_VERSION}/cmake-${CMAKE_VERSION}-linux-x86_64.tar.gz
            sudo tar -xzf cmake-${CMAKE_VERSION}-linux-x86_64.tar.gz -C /opt
            rm cmake-${CMAKE_VERSION}-linux-x86_64.tar.gz
          else
            echo "CMake ${CMAKE_VERSION} already installed at ${CMAKE_DIR}"
          fi
          
          # Force update symlinks to ensure we're using the correct version
          sudo ln -sf ${CMAKE_DIR}/bin/cmake /usr/local/bin/cmake
          sudo ln -sf ${CMAKE_DIR}/bin/ctest /usr/local/bin/ctest
          sudo ln -sf ${CMAKE_DIR}/bin/cpack /usr/local/bin/cpack
          
          # Add to PATH for this step and verify
          export PATH="${CMAKE_DIR}/bin:$PATH"
          echo "CMake version check:"
          cmake --version
          
          # Export CMAKE_DIR to GITHUB_ENV for subsequent steps
          echo "CMAKE_DIR=${CMAKE_DIR}" >> $GITHUB_ENV

      
      - name: Checkout
        uses: actions/checkout@v2
        with:
          path: 'qmodem'


      - name: Import Env
        run: cat qmodem/.github/workflows/${{ matrix.build_arch }}.env >> "$GITHUB_ENV"

      # - name: Cache openwrt SDK
      #   id: cache-sdk
      #   uses: actions/cache@v3
      #   with:
      #     path: sdk
      #     key: openwrt-sdk-${{ matrix.build_arch }}-ipk

      - name: Initialization environment
        #if: steps.cache-sdk.outputs.cache-hit != 'true'
        env:
          url_sdk: ${{ env.SDK_URL }}${{ env.SDK_NAME}}.${{ env.SDK_EXT }}
        run: |
          # Ensure CMake 3.31+ is in PATH for SDK initialization
          if [ -d "${CMAKE_DIR}" ]; then
            export PATH="${CMAKE_DIR}/bin:$PATH"
            echo "Using CMake from: ${CMAKE_DIR}/bin"
            cmake --version
          fi
          
          wget ${{ env.url_sdk }}
          file_name=${{ env.SDK_NAME}}.${{ env.SDK_EXT }}
          if [ "${{ env.SDK_EXT }}" == "tar.zst" ]; then
            mkdir sdk && tar --zstd -xvf $file_name -C ./sdk --strip-components=1
          elif [ "${{ env.SDK_EXT }}" == "tar.xz" ]; then
            mkdir sdk && tar -xvf $file_name -C ./sdk --strip-components=1
          fi
          cd sdk
          echo "src-git base https://github.com/openwrt/openwrt.git;main" > feeds.conf
          echo "src-git packages https://github.com/openwrt/packages.git;master" >> feeds.conf
          echo "src-git luci https://github.com/openwrt/luci.git;master" >> feeds.conf
          echo "src-git routing https://github.com/openwrt/routing.git;master"  >> feeds.conf
          ./scripts/feeds update -a
          ./scripts/feeds install -a
          cd ..
          echo "src-link qmodem `pwd`/qmodem" >> sdk/feeds.conf
          cd sdk
          ./scripts/feeds update qmodem
          ./scripts/feeds install -a -p qmodem
          cd ..
          
          # Fix recursive Kconfig dependencies
          chmod +x qmodem/.github/workflows/fix-kconfig-dependencies.sh
          qmodem/.github/workflows/fix-kconfig-dependencies.sh sdk
          
          cd sdk
          echo "CONFIG_ALL_NONSHARED=n" > .config
          echo "CONFIG_ALL_KMODS=n" >> .config
          echo "CONFIG_ALL=n" >> .config
          echo "CONFIG_AUTOREMOVE=n" >> .config
          echo "CONFIG_LUCI_LANG_zh_Hans=y" >> .config
          
          cat ../qmodem/.github/workflows/openwrt_package.config >> .config
          sed -i '/^CONFIG_PACKAGE_apk/d' .config
          sed -i '/^CONFIG_USE_APK/d' .config
          #cat .config
          make defconfig
          #cat .config
          # Do NOT run "make clean" on SDK or we lose prebuilt kernel artifacts
          make download -j$(nproc) || true
          #cat .config

      # This step ensures Kconfig fixes are applied when SDK is cached
      # (the fixes in the initialization step only run when cache-hit != 'true')
      - name: Fix Kconfig Dependencies
        run: |
          chmod +x qmodem/.github/workflows/fix-kconfig-dependencies.sh
          qmodem/.github/workflows/fix-kconfig-dependencies.sh sdk

      - name: Verify CMake Version
        run: |
          # Ensure CMake 3.31+ is in PATH
          if [ -d "${CMAKE_DIR}" ]; then
            export PATH="${CMAKE_DIR}/bin:$PATH"
            echo "PATH=${CMAKE_DIR}/bin:$PATH" >> $GITHUB_ENV
          fi
          
          echo "CMake version verification:"
          cmake --version
          
          # Check if CMake version is at least 3.31
          CMAKE_VERSION_OUTPUT=$(cmake --version | head -n1)
          echo "Found: $CMAKE_VERSION_OUTPUT"
          
          # Extract version number using sed for better portability
          CMAKE_VER=$(cmake --version | sed -n 's/cmake version \([0-9]*\.[0-9]*\).*/\1/p' | head -1)
          
          # Validate that we successfully extracted a version
          if [ -z "$CMAKE_VER" ]; then
            echo "ERROR: Failed to extract CMake version from output"
            exit 1
          fi
          
          echo "Detected CMake version: $CMAKE_VER"
          
          # Compare versions (split on . and compare major.minor)
          MAJOR=$(echo $CMAKE_VER | cut -d. -f1)
          MINOR=$(echo $CMAKE_VER | cut -d. -f2)
          
          # Validate MAJOR and MINOR are not empty
          if [ -z "$MAJOR" ] || [ -z "$MINOR" ]; then
            echo "ERROR: Invalid version format: $CMAKE_VER"
            exit 1
          fi
          
          # Check version requirements
          VERSION_ERROR="ERROR: CMake version $CMAKE_VER is less than required 3.31"
          
          if [ "$MAJOR" -lt 3 ]; then
            echo "$VERSION_ERROR"
            exit 1
          fi
          
          if [ "$MAJOR" -eq 3 ] && [ "$MINOR" -lt 31 ]; then
            echo "$VERSION_ERROR"
            exit 1
          fi
          
          echo "✅ CMake version check passed: $CMAKE_VER >= 3.31"

      - name: Compile QModem
        id: compile
        run: |

          
          if [ -d "${CMAKE_DIR}" ]; then
            export PATH="${CMAKE_DIR}/bin:$PATH"
            echo "Using CMake from: ${CMAKE_DIR}/bin"
            cmake --version
            # Override SDK host tools to use the required CMake 3.31+
            mkdir -p sdk/staging_dir/host/bin
            ln -sf "${CMAKE_DIR}/bin/cmake" sdk/staging_dir/host/bin/cmake
            ln -sf "${CMAKE_DIR}/bin/ctest" sdk/staging_dir/host/bin/ctest
            ln -sf "${CMAKE_DIR}/bin/cpack" sdk/staging_dir/host/bin/cpack
          fi
      
          cd sdk
          ./scripts/feeds update qmodem
          ./scripts/feeds install -a -p qmodem
      
          clean_list() {
            tr -d '\r' < "$1" | sed -e 's/#.*$//' -e '/^[[:space:]]*$/d'
          }
          
          build_list() {
            local listfile="$1"
            while IFS= read -r package; do
              echo "::group::Building ${package}"
              echo "=== Building ${package} ==="
              make "package/${package}/compile" -j"$(nproc)" V=sc
              echo "::endgroup::"
            done < <(clean_list "$listfile")
          }
      
          build_list ../qmodem/.github/workflows/qmodem_package_generic
          build_list ../qmodem/.github/workflows/qmodem_package_arch

          ls -R bin/packages || true
          ls "bin/packages/${SDK_ARCH}/qmodem/" || true

          echo "status=success" >> $GITHUB_OUTPUT
          echo "FIRMWARE=$(pwd)/bin/packages/${{ env.SDK_ARCH }}/qmodem/" >> $GITHUB_ENV

      - name: Upload QModem
        if: ${{ steps.compile.outputs.status == 'success' }}
        uses: actions/upload-artifact@v4
        with:
          name: QModem-${{ matrix.build_arch }}
          path: ${{ env.FIRMWARE }}*
          retention-days: 7

  job_release_artifacts:
    name: Release Artifacts
    needs: [job_build_qmodem, job_prepare]
    #runs-on: ubuntu-latest
    runs-on: self-hosted
    if: ${{ needs.job_prepare.outputs.push_type == 'tag' }}
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
        
      - name: Download Release Note
        uses: actions/download-artifact@v4
        with:
          name: Release Note
          path: release_note

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2.2.2
        if: ${{ needs.job_prepare.outputs.push_type == 'tag' }}
        with:
          body_path: release_note/release_note.md
          generate_release_notes: true
          tag_name: ${{ needs.job_prepare.outputs.tag_name }}
          prerelease: ${{ contains(needs.job_prepare.outputs.tag_name, '-beta') || contains(needs.job_prepare.outputs.tag_name, '-rc') }}
          files: artifacts/**/*.ipk
